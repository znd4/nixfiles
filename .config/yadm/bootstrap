#!/usr/bin/env python3
import asyncio
import functools
import site
from contextlib import contextmanager
import getpass
import io
import os
import platform
import shlex
import shutil
import subprocess as sp
import sys
import tempfile
import zipfile
from functools import lru_cache
from pathlib import Path
from typing import Callable, Iterator

# ~/.local/lib/pythonX.Y/site-packages might not exist when script starts
# So we need to manually add it to sys.path
site.addsitedir(site.getusersitepackages())

HEADLESS = os.getenv("HEADLESS", "false").lower() == "true"
GLOBAL_CRATES = ["lolcate-rs"]
UBUNTU_PACKAGES = [
    "python3-pip",
    # for pyenv
    "libedit-dev",
    "build-essential",
    "libssl-dev",
    "zlib1g-dev",
    "libbz2-dev",
    "libreadline-dev",
    "libsqlite3-dev",
    "curl",
    "libncursesw5-dev",
    "xz-utils",
    "tk-dev",
    "libxml2-dev",
    "libxmlsec1-dev",
    "libffi-dev",
    "liblzma-dev",
]
if not HEADLESS:
    UBUNTU_PACKAGES.extend(
        [
            "libgmp-dev",
            "fonts-firacode",
        ]
    )

BREW_PACKAGES = [
    "bat",
    "black",
    "brevdev/homebrew-brev/brev",
    "cookiecutter",
    "copier",
    "git-delta",
    "direnv",
    "distrobox",
    "fd",
    "fnm",
    "fzf",
    "gh",
    "git-lfs",
    "go",
    "gum",
    "hatch",
    "httpie",
    # "bundler",
    # "jekyll",
    "isort",
    "lazygit",
    "neovim",
    "nodejs",
    "pipx",
    "pipenv",
    "podman",
    "pre-commit",
    "ripgrep",
    "starship",
    "stylua",
    "thefuck",
    "tmux",
    "zoxide",
    "zsh",
]

BREW_TAPS = []

if not HEADLESS:
    BREW_TAPS.append("homebrew/linux-fonts")
    BREW_PACKAGES.extend(
        [
            "joplin-cli",
            "texlive",
            "font-symbols-only-nerd-font",
        ]
    )
NIX_ENV_PACKAGES = ["myPackages"]
INSTALL_TEXLIVE = os.getenv("INSTALL_TEXLIVE", "true").lower() == "true"

INSTALL_KMONAD = (not HEADLESS) and os.getenv(
    "INSTALL_KMONAD", "true"
).lower() == "true"


def main():
    guarantee_yadm()
    install_ubuntu_packages(*UBUNTU_PACKAGES)
    brew_tap(*BREW_TAPS)
    brew_install(*BREW_PACKAGES)
    install_clipboard()
    install_docker_compose()
    install_pyenv()

    install_rustup()

    sp.check_call(["rustup", "default", "stable"])
    sp.check_call(["cargo", "install", *GLOBAL_CRATES])
    install_py_launcher()

    # install_nix_env_packages(*NIX_ENV_PACKAGES)

    kmonad()
    print("done with kmonad")

    nix_shell = Path.home() / ".local" / "bin" / "nix-zsh"
    sp.check_call(
        f"echo '{nix_shell}' | sudo bash -c 'cat >> /etc/shells'",
        shell=True,
        text=True,
        stdin=sys.stdin,
    )

    install_tpm("tmux-plugins/tpm", "tmux-plugins/tmux-sensible")
    pipx_install("pre-commit", "black", "isort", "ruff")

    symlink_fonts()


def skip_if(cond: bool | Callable[[], bool]):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            if cond is True:
                return

            if callable(cond) and cond():
                return

            return func(*args, **kwargs)

        return wrapper

    return decorator


def install_homebrew():
    if shutil.which("brew"):
        return
    with download_script(
        "https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh"
    ) as installer:
        sp.check_call(["bash", installer])
    os.environ["PATH"] = "/home/linuxbrew/.linuxbrew/bin:" + os.environ["PATH"]


def install_rustup():
    if shutil.which("rustup"):
        return
    with download_script("https://sh.rustup.rs") as installer:
        sp.check_call(["sh", installer], stdin=sys.stdin)


@contextmanager
def download_script(url: str) -> Iterator[Path]:
    pip_install("requests")
    import requests

    with tempfile.TemporaryDirectory() as td:
        resp = requests.get(url)
        resp.raise_for_status()

        target = Path(td) / "installer"
        target.write_text(resp.text)

        yield target


def gui_only(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        if HEADLESS:
            print("Skipping GUI-only command")
            return
        return func(*args, **kwargs)

    return wrapper


def haskell_stack():
    if shutil.which("stack"):
        print("Stack already installed, skipping")
        return
    sp.check_call(
        "curl -sSL https://get.haskellstack.org/ | sh", shell=True, stdin=sys.stdin
    )


def env_patch(key: str, val: str) -> Callable[[Callable], Callable]:
    def decorator(func: Callable):
        @functools.wraps(func)
        def wrapped(*args, **kwargs):
            original = os.environ.get(key, None)
            os.environ[key] = val
            try:
                func(*args, **kwargs)
            finally:
                if original is None:
                    os.environ.pop(key)
                    return
                os.environ[key] = original

        return wrapped

    return decorator


def brew_tap(*taps: str):
    for tap in taps:
        sp.check_call([brew_path("brew"), "tap", tap])


@skip_if(lambda: HEADLESS)
def install_nerd_font_symbols():
    if "nerd" in sp.check_output(["fc-list"], text=True).lower():
        return

    proc = sp.Popen(
        [
            "gh",
            "release",
            "download",
            "--repo=ryanoasis/nerd-fonts",
            "--pattern=*SymbolsOnly.tar.xz",
            "--output=-",
        ],
        stdout=sp.PIPE,
    )

    # Define the fonts directory
    fonts_dir = Path.home() / ".local" / "share" / "fonts"

    # Create the fonts directory if it doesn't exist
    fonts_dir.mkdir(parents=True, exist_ok=True)

    # Extract all files into the fonts directory
    sp.check_call(["tar", "--xz", "-xf", "-", "-C", str(fonts_dir)], stdin=proc.stdout)

    sp.check_call(["fc-cache", "-f", "-v"], stdin=sys.stdin)


@env_patch("LD_LIBRARY_PATH", "/usr/lib/x86_64-linux-gnu")
@env_patch("LIBRARY_PATH", "/usr/lib/x86_64-linux-gnu")
@skip_if(lambda: HEADLESS)
def kmonad():
    if not INSTALL_KMONAD:
        print("Skipping kmonad setup")
        return
    print(f"{os.environ['LD_LIBRARY_PATH']=}")

    print("running kmonad setup")
    haskell_stack()
    # create uinput group if it doesn't already exist
    sp.check_call(["sudo", "groupadd", "uinput", "--force"], stdin=sys.stdin)
    # add current user to uinput group and input group
    for group in ["uinput", "input"]:
        sp.check_call(
            [
                "sudo",
                "usermod",
                "-aG",
                group,
                getpass.getuser(),
            ],
            stdin=sys.stdin,
        )

    # add to udev rules
    # copy ~/.config/kmonad/udev.rules to /etc/udev/rules.d/99-kmonad.rules
    # then reload udev rules
    sp.check_call(["sudo", "mkdir", "-p", "/etc/udev/rules.d/"], stdin=sys.stdin)
    sp.check_call(
        [
            "sudo",
            "cp",
            Path.home() / ".config/kmonad/udev.rules",
            "/etc/udev/rules.d/99-kmonad.rules",
        ],
        stdin=sys.stdin,
    )
    sp.check_call(["sudo", "udevadm", "control", "--reload-rules"], stdin=sys.stdin)

    # clone https://github.com/kmonad/kmonad into temporary directory
    with tempfile.TemporaryDirectory() as tmpdir:
        build_and_install_kmonad(Path(tmpdir))

    sp.check_call(["systemctl", "--user", "enable", "kmonad.service"], stdin=sys.stdin)
    sp.check_call(["systemctl", "--user", "restart", "kmonad.service"], stdin=sys.stdin)


def build_and_install_kmonad(dir_: Path):
    if shutil.which("kmonad"):
        print("kmonad already installed, skipping")
        return

    sp.check_call(
        [
            "git",
            "clone",
            "https://github.com/kmonad/kmonad",
            str(dir_),
        ],
        stdin=sys.stdin,
    )

    # here because it won't be installed when we first start the script
    pip_install("ruamel.yaml")
    from ruamel.yaml import YAML

    stack_yaml_path = dir_ / "stack.yaml"
    yaml = YAML()
    stack_config = {}

    # Check if stack.yaml already exists and load its content
    if stack_yaml_path.is_file():
        with open(stack_yaml_path, "r") as stack_yaml:
            stack_config = yaml.load(stack_yaml)

    extra_lib_dirs = "extra-lib-dirs"

    stack_config[extra_lib_dirs] = [
        *stack_config.get(extra_lib_dirs, []),
        "/usr/lib/x86_64-linux-gnu",
    ]

    # Save the modified stack.yaml file
    with open(stack_yaml_path, "w") as stack_yaml:
        yaml.dump(stack_config, stack_yaml)

    def check_call(args):
        return sp.check_call(args, stdin=sys.stdin, cwd=dir_)

    check_call(["stack", "setup"])
    check_call(["stack", "build"])
    check_call(["stack", "install"])


def guarantee_yadm():
    """
    Install yadm if it doesn't exist.
    This is useful when we need to invoke this script directly,
    such as in a brev.dev environment.
    """
    if shutil.which("yadm"):
        print("yadm already installed, skipping")
        return
    gh_install("TheLocehiliosan/yadm")


@lru_cache
def install_pip():
    try:
        sp.check_call([sys.executable, "-m", "pip", "--version"])
    except Exception:
        pass
    else:
        return

    try:
        import ensurepip

        ensurepip.bootstrap(user=True)
    except Exception:
        raise Exception("failed to get pip")


@functools.lru_cache()
def pip_install(*packages: str):
    install_pip()
    print(f"pip installing {', '.join(packages)}")
    sp.check_call(
        [
            sys.executable,
            "-m",
            "pip",
            "install",
            "--user",
            *packages,
        ]
    )


def install_ubuntu_packages(*pkgs: str):
    if not shutil.which("apt-get"):
        print("Not on Ubuntu, skipping apt installation")
        return
    sp.check_call(["sudo", "apt-get", "install", "-y", *pkgs])


def install_clipboard():
    """See https://github.com/Slackadays/clipboard"""
    if shutil.which("cb"):
        return

    pip_install("requests")
    import requests

    r = requests.get(
        "https://github.com/Slackadays/Clipboard/releases/download/0.7.1/clipboard-linux-amd64.zip"
    )
    r.raise_for_status()
    with tempfile.TemporaryDirectory() as tmpdir:
        with zipfile.ZipFile(io.BytesIO(r.content)) as zf:
            zf.extractall(tmpdir)
        shutil.copy(Path(tmpdir) / "bin" / "cb", Path.home() / ".local" / "bin" / "cb")
        sp.check_call(["sudo", "cp", Path(tmpdir) / "bin" / "cb", "/usr/local/bin/cb"])
        sp.check_call(shlex.split("sudo chmod +x /usr/local/bin/cb"))
        sp.check_call("sudo cp lib/*.so /usr/local/lib/", shell=True, cwd=tmpdir)


def install_tpm(*plugins: str):
    plugins_dir = Path.home() / ".tmux" / "plugins"
    plugins_dir.mkdir(parents=True, exist_ok=True)

    for plugin in plugins:
        target_dir = plugins_dir / plugin.split("/")[-1]

        if target_dir.exists() and not sp.call(
            ["git", "rev-parse", "--is-inside-work-tree"], cwd=target_dir
        ):
            print(f"{plugin} already installed, skipping")
            continue

        if target_dir.exists():
            shutil.rmtree(target_dir)

        pip_install("furl")
        import furl

        sp.check_call(
            [
                "git",
                "clone",
                (furl.furl("https://github.com") / plugin).url,
                str(target_dir),
            ]
        )


@functools.lru_cache()
def install_gh_install():
    sp.check_call(
        [
            "gh",
            "extension",
            "install",
            # "--force",
            "--pin=patch-1",
            "znd4/gh-install",
        ],
        stdin=sys.stdin,
    )


linux_only = skip_if(lambda: platform.system() != "Linux")


DOCKER_PLUGINS_DIR = Path.home() / ".docker" / "cli-plugins"


@linux_only
@env_patch("GH_BINPATH", str(DOCKER_PLUGINS_DIR))
def install_docker_compose():
    if (DOCKER_PLUGINS_DIR / "docker-compose").is_file():
        print("not installing docker compose")
        return

    print("installing docker compose")
    DOCKER_PLUGINS_DIR.mkdir(parents=True, exist_ok=True)
    gh_install("docker/compose")


@skip_if(not sys.stdout.isatty())
def gh_install(repo: str):
    install_gh_install()
    sp.check_call(["gh", "install", repo], stdin=sys.stdin)


def install_pyenv():
    pyenv_root = Path.home() / ".pyenv"
    if not pyenv_root.is_dir():
        sp.check_call(
            [
                "git",
                "clone",
                "https://github.com/pyenv/pyenv.git",
                pyenv_root,
            ]
        )
    pyenv = pyenv_root / "bin" / "pyenv"
    versions = ["3.10", "3.11"]
    globals = set(sp.check_output([pyenv, "global"], text=True).strip().split("\n"))
    for version in versions:
        if version in globals or any(
            line.strip().startswith(version)
            for line in sp.check_output(
                [pyenv, "versions"],
                text=True,
            ).split("\n")
        ):
            continue
        sp.check_call([pyenv, "install", version])

    sp.check_call([pyenv, "global", *versions])


BREW_BIN = Path("/") / "home" / "linuxbrew" / ".linuxbrew" / "bin"


def brew_path(exe: str) -> Path:
    return BREW_BIN / exe


def path_to_brew() -> Path:
    return BREW_BIN / "brew"


def brew_install(*pkgs: str):
    install_homebrew()

    pip_install("more-itertools")
    import more_itertools as mi

    for chunk in mi.chunked(pkgs, 10):
        sp.check_call([path_to_brew(), "install", *chunk])


def install_py_launcher():
    if shutil.which("py"):
        return

    gh_install("brettcannon/python-launcher")


@skip_if(HEADLESS)
def symlink_fonts():
    fonts_dir = Path.home() / ".local" / "share" / "fonts"
    if not fonts_dir.is_dir():
        os.symlink(
            "/home/linuxbrew/.linuxbrew/share/fonts",
            str(fonts_dir),
        )

    sp.check_call(["fc-cache", "-fv"])


async def pipx_install_async(*packages):
    await asyncio.gather(
        *[
            asyncio.create_subprocess_exec(
                str(brew_path("pipx")),
                "install",
                package,
            )
            for package in packages
        ]
    )


def pipx_install(*args):
    asyncio.run(pipx_install_async(*args))


if __name__ == "__main__":
    main()
