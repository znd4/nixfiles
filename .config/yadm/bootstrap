#!/usr/bin/env python3
import functools
import getpass
from functools import lru_cache
import os
import shlex
import shutil
import subprocess as sp
import sys
import tempfile
from pathlib import Path
from typing import Callable

HEADLESS = os.getenv("HEADLESS", "false").lower() == "true"
GLOBAL_CRATES = ["lolcate-rs"]
UBUNTU_PACKAGES = [
    "libgmp-dev", # for haskell stack
    "python3-pip",
]
INSTALL_TEXLIVE = os.getenv("INSTALL_TEXLIVE", "true").lower() == "true"

INSTALL_KMONAD = (not HEADLESS) and os.getenv("INSTALL_KMONAD", "true").lower() == "true"
    

nix_bin = Path.home() / ".nix-profile" / "bin"


def main():
    guarantee_yadm()
    install_ubuntu_packages(*UBUNTU_PACKAGES)

    if not shutil.which("nix-env"):
        pip_install("requests")
        import requests

        res = requests.get("https://nixos.org/nix/install")
        res.raise_for_status()
        sp.check_call(["sh", "-c", res.text, "--daemon"])

    nix_shell_run("rustup", "default", "stable")
    nix_shell_run("cargo", "install", *GLOBAL_CRATES)

    sp.check_call(
        [
            full_nix_cmd_path("nix-env"),
            "-iA",
            "nixpkgs.myPackages",
        ]
    )  # mostly installs fonts

    if shutil.which("fc-cache"):
        sp.check_call(["fc-cache"])

    if INSTALL_KMONAD:
        os.environ["LD_LIBRARY_PATH"] = "/usr/lib/x86_64-linux-gnu"

    kmonad()
    print("done with kmonad")

    nix_shell = Path.home() / ".local" / "bin" / "nix-zsh"
    sp.check_call(
        f"echo '{nix_shell}' | sudo bash -c 'cat >> /etc/shells'",
        shell=True,
        text=True,
        stdin=sys.stdin,
    )


def gui_only(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        if HEADLESS:
            print("Skipping GUI-only command")
            return
        return func(*args, **kwargs)

    return wrapper


def haskell_stack():
    if shutil.which("stack"):
        print("Stack already installed, skipping")
        return
    sp.check_call(
        "curl -sSL https://get.haskellstack.org/ | sh", shell=True, stdin=sys.stdin
    )

def env_patch(key: str, val: str) -> Callable[[Callable], Callable]:
    def decorator(func: Callable):
        @functools.wraps(func)
        def wrapped(*args, **kwargs):
            original = os.environ.get(key, None)
            os.environ[key] = val
            try:
                func(*args, **kwargs)
            finally:
                if original is None:
                    os.environ.pop(key)
                    return
                os.environ = original

        return wrapped
    return decorator


@env_patch("LD_LIBRARY_PATH", "/usr/lib/x86_64-linux-gnu")
@env_patch("LIBRARY_PATH", "/usr/lib/x86_64-linux-gnu")
@gui_only
def kmonad():
    if not INSTALL_KMONAD:
        print("Skipping kmonad setup")
        return
    print(f"{os.environ['LD_LIBRARY_PATH']=}")


    print("running kmonad setup")
    haskell_stack()
    # create uinput group if it doesn't already exist
    sp.check_call(["sudo", "groupadd", "uinput", "--force"], stdin=sys.stdin)
    # add current user to uinput group and input group
    for group in ["uinput", "input"]:
        sp.check_call(
            [
                "sudo",
                "usermod",
                "-aG",
                group,
                getpass.getuser(),
            ],
            stdin=sys.stdin,
        )

    # add to udev rules
    # copy ~/.config/kmonad/udev.rules to /etc/udev/rules.d/99-kmonad.rules
    # then reload udev rules
    sp.check_call(["sudo", "mkdir", "-p", "/etc/udev/rules.d/"], stdin=sys.stdin)
    sp.check_call(
        [
            "sudo",
            "cp",
            Path.home() / ".config/kmonad/udev.rules",
            "/etc/udev/rules.d/99-kmonad.rules",
        ],
        stdin=sys.stdin,
    )
    sp.check_call(["sudo", "udevadm", "control", "--reload-rules"], stdin=sys.stdin)

    # clone https://github.com/kmonad/kmonad into temporary directory
    with tempfile.TemporaryDirectory() as tmpdir:
        build_and_install_kmonad(Path(tmpdir))

    sp.check_call(["systemctl", "--user", "enable", "kmonad.service"], stdin=sys.stdin)
    sp.check_call(["systemctl", "--user", "restart", "kmonad.service"], stdin=sys.stdin)


def build_and_install_kmonad(dir_: Path):
    if shutil.which("kmonad"):
        print("kmonad already installed, skipping")
        return

    sp.check_call(
        [
            "git",
            "clone",
            "https://github.com/kmonad/kmonad",
            str(dir_),
        ],
        stdin=sys.stdin,
    )

    # here because it won't be installed when we first start the script
    pip_install("ruamel.yaml")
    from ruamel.yaml import YAML

    stack_yaml_path = dir_ / "stack.yaml"
    yaml = YAML()
    stack_config = {}

    # Check if stack.yaml already exists and load its content
    if stack_yaml_path.is_file():
        with open(stack_yaml_path, "r") as stack_yaml:
            stack_config = yaml.load(stack_yaml)

    extra_lib_dirs = "extra-lib-dirs"

    stack_config[extra_lib_dirs] = [
        *stack_config.get(extra_lib_dirs, []),
        "/usr/lib/x86_64-linux-gnu",
    ]

    
    # Save the modified stack.yaml file
    with open(stack_yaml_path, "w") as stack_yaml:
        yaml.dump(stack_config, stack_yaml)



    check_call = lambda args: sp.check_call(args, stdin=sys.stdin, cwd=dir_)
    check_call(["stack", "setup"])
    check_call(["stack", "build"])
    check_call(["stack", "install"])


def guarantee_yadm():
    """
    Install yadm if it doesn't exist.
    This is useful when we need to invoke this script directly, such as in a brev.dev environment.
    """
    if shutil.which("yadm"):
        print("yadm already installed, skipping")
        return
    yadm_path = Path.home() / ".local" / "bin" / "yadm"
    sp.check_call(
        [
            "curl",
            "-fLo",
            yadm_path,
            "https://github.com/TheLocehiliosan/yadm/raw/master/yadm",
            "&&",
            "chmod",
            "a+x",
            yadm_path,
        ]
    )


def full_nix_cmd_path(cmd: str) -> Path:
    bin_path = nix_bin / cmd
    if bin_path.is_file():
        return bin_path
    fallback = shutil.which(cmd)
    if fallback:
        return Path(fallback)
    raise EnvironmentError(f"Couldn't find {cmd} on PATH or in {nix_bin}")


def nix_shell_run(*args: str):
    sp.check_call(
        [
            full_nix_cmd_path("nix-shell"),
            "--run",
            shlex.join(["bash", "-c", shlex.join(args)]),
            str(Path.home() / "shell.nix"),
        ]
    )

@lru_cache
def install_pip():
    try:
        sp.check_call([sys.executable, "-m", "pip", "--version"])
    except:
        pass
    else:
        return

    try:
        import ensurepip
        ensurepip.bootstrap(user=True)
    except:
        raise Exception("failed to get pip")


def pip_install(*packages: str):
    install_pip()
    print(f"pip installing {', '.join(packages)}")
    sp.check_call(
        [
            sys.executable,
            "-m",
            "pip",
            "install",
            "--user",
            *packages,
        ]
    )



def install_ubuntu_packages(*pkgs: str):
    if not shutil.which("apt-get"):
        print("Not on Ubuntu, skipping apt installation")
        return
    sp.check_call(["sudo", "apt-get", "install", "-y", *pkgs])


if __name__ == "__main__":
    main()
