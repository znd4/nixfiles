#!/usr/bin/env python3
import functools
import getpass
import io
import os
import platform
import shlex
import shutil
import subprocess as sp
import sys
import tempfile
import zipfile
from functools import lru_cache
from pathlib import Path
from typing import Callable

HEADLESS = os.getenv("HEADLESS", "false").lower() == "true"
GLOBAL_CRATES = ["lolcate-rs"]
UBUNTU_PACKAGES = [
    "libgmp-dev",  # for haskell stack
    "python3-pip",
    "fonts-firacode",
]
NIX_ENV_PACKAGES = ["myPackages"]
INSTALL_TEXLIVE = os.getenv("INSTALL_TEXLIVE", "true").lower() == "true"

INSTALL_KMONAD = (not HEADLESS) and os.getenv(
    "INSTALL_KMONAD", "true"
).lower() == "true"


nix_bin = Path.home() / ".nix-profile" / "bin"


def main():
    guarantee_yadm()
    install_ubuntu_packages(*UBUNTU_PACKAGES)
    install_nerd_font_symbols()
    install_clipboard()
    install_docker_compose()

    if not shutil.which("nix-env"):
        pip_install("requests")
        import requests

        res = requests.get("https://nixos.org/nix/install")
        res.raise_for_status()
        sp.check_call(["sh", "-c", res.text, "--daemon"])

    nix_shell_run("rustup", "default", "stable")
    nix_shell_run("cargo", "install", *GLOBAL_CRATES)
    install_py_launcher()

    install_nix_env_packages(*NIX_ENV_PACKAGES)

    if shutil.which("fc-cache"):
        sp.check_call(["fc-cache"])

    kmonad()
    print("done with kmonad")

    nix_shell = Path.home() / ".local" / "bin" / "nix-zsh"
    sp.check_call(
        f"echo '{nix_shell}' | sudo bash -c 'cat >> /etc/shells'",
        shell=True,
        text=True,
        stdin=sys.stdin,
    )

    install_tpm("tmux-plugins/tpm", "tmux-plugins/tmux-sensible")


def install_nix_env_packages(*packages: str):
    sp.check_call(
        [full_nix_cmd_path("nix-env"), "-iA", *(f"nixpkgs.{p}" for p in packages)]
    )


def gui_only(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        if HEADLESS:
            print("Skipping GUI-only command")
            return
        return func(*args, **kwargs)

    return wrapper


def haskell_stack():
    if shutil.which("stack"):
        print("Stack already installed, skipping")
        return
    sp.check_call(
        "curl -sSL https://get.haskellstack.org/ | sh", shell=True, stdin=sys.stdin
    )


def env_patch(key: str, val: str) -> Callable[[Callable], Callable]:
    def decorator(func: Callable):
        @functools.wraps(func)
        def wrapped(*args, **kwargs):
            original = os.environ.get(key, None)
            os.environ[key] = val
            try:
                func(*args, **kwargs)
            finally:
                if original is None:
                    os.environ.pop(key)
                    return
                os.environ[key] = original

        return wrapped

    return decorator


@gui_only
def install_nerd_font_symbols():
    if "nerd" in sp.check_output(["fc-list"], text=True).lower():
        return

    proc = sp.Popen(
        nix_shell_cmd(
            "gh",
            "release",
            "download",
            "--repo=ryanoasis/nerd-fonts",
            "--pattern=*SymbolsOnly.tar.xz",
            "--output=-",
        ),
        stdout=sp.PIPE,
    )

    # Define the fonts directory
    fonts_dir = Path.home() / ".local" / "share" / "fonts"

    # Create the fonts directory if it doesn't exist
    fonts_dir.mkdir(parents=True, exist_ok=True)

    # Extract all files into the fonts directory
    sp.check_call(["tar", "--xz", "-xf", "-", "-C", str(fonts_dir)], stdin=proc.stdout)

    sp.check_call(["fc-cache", "-f", "-v"], stdin=sys.stdin)


@env_patch("LD_LIBRARY_PATH", "/usr/lib/x86_64-linux-gnu")
@env_patch("LIBRARY_PATH", "/usr/lib/x86_64-linux-gnu")
@gui_only
def kmonad():
    if not INSTALL_KMONAD:
        print("Skipping kmonad setup")
        return
    print(f"{os.environ['LD_LIBRARY_PATH']=}")

    print("running kmonad setup")
    haskell_stack()
    # create uinput group if it doesn't already exist
    sp.check_call(["sudo", "groupadd", "uinput", "--force"], stdin=sys.stdin)
    # add current user to uinput group and input group
    for group in ["uinput", "input"]:
        sp.check_call(
            [
                "sudo",
                "usermod",
                "-aG",
                group,
                getpass.getuser(),
            ],
            stdin=sys.stdin,
        )

    # add to udev rules
    # copy ~/.config/kmonad/udev.rules to /etc/udev/rules.d/99-kmonad.rules
    # then reload udev rules
    sp.check_call(["sudo", "mkdir", "-p", "/etc/udev/rules.d/"], stdin=sys.stdin)
    sp.check_call(
        [
            "sudo",
            "cp",
            Path.home() / ".config/kmonad/udev.rules",
            "/etc/udev/rules.d/99-kmonad.rules",
        ],
        stdin=sys.stdin,
    )
    sp.check_call(["sudo", "udevadm", "control", "--reload-rules"], stdin=sys.stdin)

    # clone https://github.com/kmonad/kmonad into temporary directory
    with tempfile.TemporaryDirectory() as tmpdir:
        build_and_install_kmonad(Path(tmpdir))

    sp.check_call(["systemctl", "--user", "enable", "kmonad.service"], stdin=sys.stdin)
    sp.check_call(["systemctl", "--user", "restart", "kmonad.service"], stdin=sys.stdin)


def build_and_install_kmonad(dir_: Path):
    if shutil.which("kmonad"):
        print("kmonad already installed, skipping")
        return

    sp.check_call(
        [
            "git",
            "clone",
            "https://github.com/kmonad/kmonad",
            str(dir_),
        ],
        stdin=sys.stdin,
    )

    # here because it won't be installed when we first start the script
    pip_install("ruamel.yaml")
    from ruamel.yaml import YAML

    stack_yaml_path = dir_ / "stack.yaml"
    yaml = YAML()
    stack_config = {}

    # Check if stack.yaml already exists and load its content
    if stack_yaml_path.is_file():
        with open(stack_yaml_path, "r") as stack_yaml:
            stack_config = yaml.load(stack_yaml)

    extra_lib_dirs = "extra-lib-dirs"

    stack_config[extra_lib_dirs] = [
        *stack_config.get(extra_lib_dirs, []),
        "/usr/lib/x86_64-linux-gnu",
    ]

    # Save the modified stack.yaml file
    with open(stack_yaml_path, "w") as stack_yaml:
        yaml.dump(stack_config, stack_yaml)

    check_call = lambda args: sp.check_call(args, stdin=sys.stdin, cwd=dir_)
    check_call(["stack", "setup"])
    check_call(["stack", "build"])
    check_call(["stack", "install"])


def guarantee_yadm():
    """
    Install yadm if it doesn't exist.
    This is useful when we need to invoke this script directly, such as in a brev.dev environment.
    """
    if shutil.which("yadm"):
        print("yadm already installed, skipping")
        return
    gh_install("TheLocehiliosan/yadm")


def full_nix_cmd_path(cmd: str) -> Path:
    bin_path = nix_bin / cmd
    if bin_path.is_file():
        return bin_path
    fallback = shutil.which(cmd)
    if fallback:
        return Path(fallback)
    raise EnvironmentError(f"Couldn't find {cmd} on PATH or in {nix_bin}")


def nix_shell_cmd(*args: str) -> list[str | Path]:
    return [
        full_nix_cmd_path("nix-shell"),
        "--run",
        shlex.join(["bash", "-c", shlex.join(args)]),
        str(Path.home() / "shell.nix"),
    ]


def nix_shell_run(*args: str, **kwargs):
    sp.check_call(
        nix_shell_cmd(*args),
        **kwargs,
    )


@lru_cache
def install_pip():
    try:
        sp.check_call([sys.executable, "-m", "pip", "--version"])
    except Exception:
        pass
    else:
        return

    try:
        import ensurepip

        ensurepip.bootstrap(user=True)
    except Exception:
        raise Exception("failed to get pip")


@functools.lru_cache()
def pip_install(*packages: str):
    install_pip()
    print(f"pip installing {', '.join(packages)}")
    sp.check_call(
        [
            sys.executable,
            "-m",
            "pip",
            "install",
            "--user",
            *packages,
        ]
    )


def install_ubuntu_packages(*pkgs: str):
    if not shutil.which("apt-get"):
        print("Not on Ubuntu, skipping apt installation")
        return
    sp.check_call(["sudo", "apt-get", "install", "-y", *pkgs])


def install_clipboard():
    """See https://github.com/Slackadays/clipboard"""
    if shutil.which("cb"):
        return

    pip_install("requests")
    import requests

    r = requests.get(
        "https://github.com/Slackadays/Clipboard/releases/download/0.7.1/clipboard-linux-amd64.zip"
    )
    r.raise_for_status()
    with tempfile.TemporaryDirectory() as tmpdir:
        with zipfile.ZipFile(io.BytesIO(r.content)) as zf:
            zf.extractall(tmpdir)
        shutil.copy(Path(tmpdir) / "bin" / "cb", Path.home() / ".local" / "bin" / "cb")
        sp.check_call(["sudo", "cp", Path(tmpdir) / "bin" / "cb", "/usr/local/bin/cb"])
        sp.check_call(shlex.split("sudo chmod +x /usr/local/bin/cb"))
        sp.check_call("sudo cp lib/*.so /usr/local/lib/", shell=True, cwd=tmpdir)


def install_tpm(*plugins: str):
    plugins_dir = Path.home() / ".tmux" / "plugins"
    plugins_dir.mkdir(parents=True, exist_ok=True)

    for plugin in plugins:
        target_dir = plugins_dir / plugin.split("/")[-1]

        if target_dir.exists() and not sp.call(
            ["git", "rev-parse", "--is-inside-work-tree"], cwd=target_dir
        ):
            print(f"{plugin} already installed, skipping")
            continue

        if target_dir.exists():
            shutil.rmtree(target_dir)

        pip_install("furl")
        import furl

        sp.check_call(
            [
                "git",
                "clone",
                (furl.furl("https://github.com") / plugin).url,
                str(target_dir),
            ]
        )


@functools.lru_cache()
def install_gh_install():
    nix_shell_run(
        "gh",
        "extension",
        "install",
        "--force",
        "--pin=patch-1",
        "znd4/gh-install",
        stdin=sys.stdin,
    )


def linux_only(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        if platform.system() != "Linux":
            print(f"Skipping {func.__name__} on non-Linux platform")
            return
        return func(*args, **kwargs)

    return wrapper


DOCKER_PLUGINS_DIR = Path.home() / ".docker" / "cli-plugins"


@linux_only
@env_patch("GH_BINPATH", str(DOCKER_PLUGINS_DIR))
def install_docker_compose():
    if (DOCKER_PLUGINS_DIR / "docker-compose").is_file():
        print("not installing docker compose")
        return

    print("installing docker compose")
    DOCKER_PLUGINS_DIR.mkdir(parents=True, exist_ok=True)
    gh_install("docker/compose")


def gh_install(repo: str):
    install_gh_install()
    nix_shell_run("gh", "install", repo, stdin=sys.stdin)


def install_py_launcher():
    if shutil.which("py"):
        return

    gh_install("brettcannon/python-launcher")


if __name__ == "__main__":
    main()
