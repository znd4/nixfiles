* Steps to finalize:
** TODO Add parsing support for all options
** TODO Get a config with all options running
** TODO Check if we use init for cfg
** WAITING Clean up unused modules
* Article notes:
** Type restriction
restrict your types:
Callback = (Bool, Bool) vs Maybe Bool + lenses
[(Milliseconds, Button)] vs NonEmpty (Milliseconds, Button) vs (Button,
[(Milliseconds, Button)])
** Avoid nesting
the ContT withXXX transformation

*** The ExceptT transformer
**** Before refactor
#+BEGIN_SRC haskell

stmKey :: DaemonEnv -> STM (Maybe KeyEvent, IO ())
stmKey d = do
  e <- readTChan $ d^.keysIn

  tryTakeTMVar (d^.capturePoint) >>= \case
    Just f  -> pure $ (Nothing, f e)
    Nothing -> do

      (capped, cbs, cbIO) <- runCallbacks e <$> (readTVar $ d^.callbacks)
      writeTVar (d^.callbacks) cbs
      if getAny capped
        then pure $ (Nothing, cbIO)
        else do

          readTVar (d^.blocked) >>= \case
            True -> do
              modifyTVar' (d^.rerunBuf) (|> e)
              pure $ (Nothing, cbIO)
            False -> pure $ (Nothing, cbIO)
#+END_SRC
**** After refactor
#+BEGIN_SRC haskell
stmKey :: DaemonEnv -> STM (Maybe KeyEvent, IO ())
stmKey d = do
  e <- readTChan $ d^.keysIn

  let checkCapture = ExceptT $ do
        tryTakeTMVar (d^.capturePoint) >>= \case
          Just f  -> pure . Left  $ f e
          Nothing -> pure . Right $ (pure () :: IO ())

  let checkCallbacks = ExceptT $ do
        (capped, cbs, cbIO) <- runCallbacks e <$> (readTVar $ d^.callbacks)
        writeTVar (d^.callbacks) cbs
        if getAny capped
          then pure . Left  $ cbIO
          else pure . Right $ cbIO

  let checkBlocked io = ExceptT $ do
        readTVar (d^.blocked) >>= \case
          True -> do
            modifyTVar' (d^.rerunBuf) (|> e)
            pure . Left $ io
          False -> pure . Right $ io

  runExceptT (checkCapture >> checkCallbacks >>= checkBlocked) >>= \case
    Left io  -> pure (Nothing, io)
    Right io -> pure (Just e, io)
    #+END_SRC
** Why UnliftIO is cool
You can always 'compress' your actions into IO and store them in newtypes and
such without having to pass around monad typevariables.
** On EDSLs
Make your abstractions as fundamental as possible, but no more. I.e., find out
what you need to support and find the most parsimonious formulation of that.
(My issues trying to make a concurrent EDSL).
